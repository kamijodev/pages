# ドメイン駆動設計入門 読書メモ

## ドメイン

「領域」という意味
プログラムを適用する対象となる領域

- 会計システムであれば、金銭や帳票が含まれる
- 物流システムであれば、倉庫や貨物が含まれる

大切なのは何がドメインが何かではなくドメインに含まれるものが何か

## モデル

現実の事象や概念を抽象化したもの
抽象化したもののため、全てを再現するわけではない、何を取捨選択はドメインによる

例えば小説家にとってペンは文字がかけることが大事な性質
例えば文房具店にとっては値段が大事

つまり対象が同じであっても何に重きを置くかはドメインによる
ドメイン駆動設計では、ドメインの概念をモデリングして得られたモデルを**ドメインモデル**と呼ぶ
また、ドメインモデルを実装したものを**ドメインオブジェクト**と呼ぶ

## 値オブジェクト

値オブジェクトは不変である
変更行いたい場合、プリミティブ値と同じでインスタンスを再生成し、再代入するべき
値オブジェクト同士の比較処理は値オブジェクト内に実装する(言語にもよる？)

### どこまでを値オブジェクトとして実装するべきか

- そこにルールが存在しているか
- それ単体で取り扱いたいか

## エンティティ

エンティティは可変である
同じ属性であっても区別される
値オブジェクトは属性で識別されるドメインオブジェクト
エンティティは同一性によって識別されるドメインオブジェクト

## サービス

クライアントの為に何かを行うオブジェクト
ドメイン駆動設計において、サービスには二種類存在する
ドメインの為のサービスとアプリケーションの為のサービス

### ドメインサービス

値オブジェクトや、エンティティに記述すると不自然なふるまいが存在する
そういった不自然さを解決するオブジェクト

例) ユーザーの重複チェックの不自然な例

```php
$user = new User("kamijo");
$user->exists($user);
```

上の例では自分自身に重複確認を行うのはおかしい
この場合はUserServiceを定義するべき
注意点としてドメインサービスはなるべく使用しない方がよい
何故なら、値オブジェクトに残る情報が少なくなってしまう為（ドメインモデル貧血症）
具体例としてはユーザ名の変更などはエンティティに残すべき

### アプリケーションサービス

例えばユーザ機能を実現する場合に、ドメインサービスやリポジトリを使用して「ユーザを登録する」「ユーザ情報を変更する」などを行う
ドメインオブジェクトのふるまいを呼び出すのはアプリケーションサービスの役目
アプリケーションサービスがドメインオブジェクトを直接返すのはよくない
何故ならアプリケーションサービスの外でドメインオブジェクトのふるまいを呼び出せてしまう為

```php
// php しばらく書いてないので少し間違えてるかも

class client
{
  private UserApplicationService $_userApplicationService;

  public function changeName($id, $name)
  {
    $user = $this->_userApplicationService->Get(id);
    $user->changeName($name);
  }
}
```

問題点

- アプリケーションとして提供されるべきコードが各所にちらばってしまう
- データの永続化がされていない

対策

データを直接公開しない
データ転送用オブジェクト（DTO, Data Transfer Object）を利用する

```c#
public class UserData
{
  public UserData(string id, string name)
  {
    Id = id;
    Name = name;
  }

  public string Id { get; }
  public string Name { get; }
}

public class UserApplicationService
{
  private readonly IUserRepository userRepository;

  ...

  public UserData Get(string userId)
  {
    var targetId = new UserId(userId);
    var user = userRepository.Find(targetId);

    if (user == null) {
      return null;
    }

    return new UserData(user);
  }

}

```

## リポジトリ

ドメインの概念を表現しただけではアプリケーションとしてなりたたない
なぜならプログラムが実行される過程でメモリ上に展開されたデータはプログラムが終了すると消えてなくなってしまう
リポジトリはデータを永続化し、再構築するといった処理を抽象的に扱う為のオブジェクト
リポジトリには複雑な更新処理は定義しない
例) 複雑な更新処理

```c#
interface IUserRepository
{
  void UpdateName(UserId id, UserName name);
  ...
  ...
}
```

こういった処理はオブジェクトにやらせる
実際に定義する基本メソッドはsave(永続化), find(再構築), delete(破棄)
findAllはリソースを食いつぶす可能性があるので慎重に行ったほうがよい
find(idに基づく検索)では処理の条件を満たせない場合、findByUserName等の適したメソッドを定義する

### インメモリのリポジトリ

インメモリのリポジトリを用意することで、開発時にまだどのデータストアを利用するか決まっていなくてもロジックを実装することが出来る
また、インメモリのリポジトリがあればテストの際に、データベースやテーブルを用意せずとも気軽にテストを書くことが出来る
インメモリのリポジトリは連想配列を用いて作成するとよい
後続の処理に影響しないように永続化時も再構築時も新しいインスタンスを返すようにする
